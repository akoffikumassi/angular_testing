{"ast":null,"code":"import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing'; // Other imports\n\nimport { TestBed } from '@angular/core/testing';\nimport { HttpClient, HttpResponse, HttpErrorResponse } from '@angular/common/http';\nimport { asyncData, asyncError } from '../../testing/async-observable-helpers';\nimport { HeroService } from './hero.service';\ndescribe('HeroesService (with spies)', () => {\n  let httpClientSpy;\n  let heroService;\n  beforeEach(() => {\n    // TODO: spy on other methods too\n    httpClientSpy = jasmine.createSpyObj('HttpClient', ['get']);\n    heroService = new HeroService(httpClientSpy);\n  });\n  it('should return expected heroes (HttpClient called once)', done => {\n    const expectedHeroes = [{\n      id: 1,\n      name: 'A'\n    }, {\n      id: 2,\n      name: 'B'\n    }];\n    httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n    heroService.getHeroes().subscribe(heroes => {\n      expect(heroes).toEqual(expectedHeroes, 'expected heroes');\n      done();\n    }, done.fail);\n    expect(httpClientSpy.get.calls.count()).toBe(1, 'one call');\n  });\n  it('should return an error when the server returns a 404', done => {\n    const errorResponse = new HttpErrorResponse({\n      error: 'test 404 error',\n      status: 404,\n      statusText: 'Not Found'\n    });\n    httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n    heroService.getHeroes().subscribe(heroes => done.fail('expected an error, not heroes'), error => {\n      expect(error.message).toContain('test 404 error');\n      done();\n    });\n  });\n});\ndescribe('HeroesService (with mocks)', () => {\n  let httpClient;\n  let httpTestingController;\n  let heroService;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      // Import the HttpClient mocking services\n      imports: [HttpClientTestingModule],\n      // Provide the service-under-test\n      providers: [HeroService]\n    }); // Inject the http, test controller, and service-under-test\n    // as they will be referenced by each test.\n\n    httpClient = TestBed.inject(HttpClient);\n    httpTestingController = TestBed.inject(HttpTestingController);\n    heroService = TestBed.inject(HeroService);\n  });\n  afterEach(() => {\n    // After every test, assert that there are no more pending requests.\n    httpTestingController.verify();\n  }); /// HeroService method tests begin ///\n\n  describe('#getHeroes', () => {\n    let expectedHeroes;\n    beforeEach(() => {\n      heroService = TestBed.inject(HeroService);\n      expectedHeroes = [{\n        id: 1,\n        name: 'A'\n      }, {\n        id: 2,\n        name: 'B'\n      }];\n    });\n    it('should return expected heroes (called once)', () => {\n      heroService.getHeroes().subscribe(heroes => expect(heroes).toEqual(expectedHeroes, 'should return expected heroes'), fail); // HeroService should have made one request to GET heroes from expected URL\n\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n      expect(req.request.method).toEqual('GET'); // Respond with the mock heroes\n\n      req.flush(expectedHeroes);\n    });\n    it('should be OK returning no heroes', () => {\n      heroService.getHeroes().subscribe(heroes => expect(heroes.length).toEqual(0, 'should have empty heroes array'), fail);\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n      req.flush([]); // Respond with no heroes\n    });\n    it('should turn 404 into a user-friendly error', () => {\n      const msg = 'Deliberate 404';\n      heroService.getHeroes().subscribe(heroes => fail('expected to fail'), error => expect(error.message).toContain(msg));\n      const req = httpTestingController.expectOne(heroService.heroesUrl); // respond with a 404 and the error message in the body\n\n      req.flush(msg, {\n        status: 404,\n        statusText: 'Not Found'\n      });\n    });\n    it('should return expected heroes (called multiple times)', () => {\n      heroService.getHeroes().subscribe();\n      heroService.getHeroes().subscribe();\n      heroService.getHeroes().subscribe(heroes => expect(heroes).toEqual(expectedHeroes, 'should return expected heroes'), fail);\n      const requests = httpTestingController.match(heroService.heroesUrl);\n      expect(requests.length).toEqual(3, 'calls to getHeroes()'); // Respond to each request with different mock hero results\n\n      requests[0].flush([]);\n      requests[1].flush([{\n        id: 1,\n        name: 'bob'\n      }]);\n      requests[2].flush(expectedHeroes);\n    });\n  });\n  describe('#updateHero', () => {\n    // Expecting the query form of URL so should not 404 when id not found\n    const makeUrl = id => `${heroService.heroesUrl}/?id=${id}`;\n\n    it('should update a hero and return it', () => {\n      const updateHero = {\n        id: 1,\n        name: 'A'\n      };\n      heroService.updateHero(updateHero).subscribe(data => expect(data).toEqual(updateHero, 'should return the hero'), fail); // HeroService should have made one request to PUT hero\n\n      const req = httpTestingController.expectOne(heroService.heroesUrl);\n      expect(req.request.method).toEqual('PUT');\n      expect(req.request.body).toEqual(updateHero); // Expect server to return the hero after PUT\n\n      const expectedResponse = new HttpResponse({\n        status: 200,\n        statusText: 'OK',\n        body: updateHero\n      });\n      req.event(expectedResponse);\n    });\n    it('should turn 404 error into user-facing error', () => {\n      const msg = 'Deliberate 404';\n      const updateHero = {\n        id: 1,\n        name: 'A'\n      };\n      heroService.updateHero(updateHero).subscribe(heroes => fail('expected to fail'), error => expect(error.message).toContain(msg));\n      const req = httpTestingController.expectOne(heroService.heroesUrl); // respond with a 404 and the error message in the body\n\n      req.flush(msg, {\n        status: 404,\n        statusText: 'Not Found'\n      });\n    });\n    it('should turn network error into user-facing error', done => {\n      // Create mock ProgressEvent with type `error`, raised when something goes wrong at\n      // the network level. Connection timeout, DNS error, offline, etc.\n      const errorEvent = new ProgressEvent('error');\n      const updateHero = {\n        id: 1,\n        name: 'A'\n      };\n      heroService.updateHero(updateHero).subscribe(heroes => fail('expected to fail'), error => {\n        expect(error).toBe(errorEvent);\n        done();\n      });\n      const req = httpTestingController.expectOne(heroService.heroesUrl); // Respond with mock error\n\n      req.error(errorEvent);\n    });\n  }); // TODO: test other HeroService methods\n});","map":{"version":3,"sources":["/home/yadadev/work/trainings/mean/angular/angular_testing/src/app/model/hero.service.spec.ts"],"names":["HttpClientTestingModule","HttpTestingController","TestBed","HttpClient","HttpResponse","HttpErrorResponse","asyncData","asyncError","HeroService","describe","httpClientSpy","heroService","beforeEach","jasmine","createSpyObj","it","done","expectedHeroes","id","name","get","and","returnValue","getHeroes","subscribe","heroes","expect","toEqual","fail","calls","count","toBe","errorResponse","error","status","statusText","message","toContain","httpClient","httpTestingController","configureTestingModule","imports","providers","inject","afterEach","verify","req","expectOne","heroesUrl","request","method","flush","length","msg","requests","match","makeUrl","updateHero","data","body","expectedResponse","event","errorEvent","ProgressEvent"],"mappings":"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","sourcesContent":["import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\n// Other imports\nimport { TestBed } from '@angular/core/testing';\nimport { HttpClient, HttpResponse, HttpErrorResponse } from '@angular/common/http';\nimport { asyncData, asyncError } from '../../testing/async-observable-helpers';\nimport { HeroService } from './hero.service';\ndescribe('HeroesService (with spies)', () => {\n    let httpClientSpy;\n    let heroService;\n    beforeEach(() => {\n        // TODO: spy on other methods too\n        httpClientSpy = jasmine.createSpyObj('HttpClient', ['get']);\n        heroService = new HeroService(httpClientSpy);\n    });\n    it('should return expected heroes (HttpClient called once)', (done) => {\n        const expectedHeroes = [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];\n        httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n        heroService.getHeroes().subscribe(heroes => {\n            expect(heroes).toEqual(expectedHeroes, 'expected heroes');\n            done();\n        }, done.fail);\n        expect(httpClientSpy.get.calls.count()).toBe(1, 'one call');\n    });\n    it('should return an error when the server returns a 404', (done) => {\n        const errorResponse = new HttpErrorResponse({\n            error: 'test 404 error',\n            status: 404, statusText: 'Not Found'\n        });\n        httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n        heroService.getHeroes().subscribe(heroes => done.fail('expected an error, not heroes'), error => {\n            expect(error.message).toContain('test 404 error');\n            done();\n        });\n    });\n});\ndescribe('HeroesService (with mocks)', () => {\n    let httpClient;\n    let httpTestingController;\n    let heroService;\n    beforeEach(() => {\n        TestBed.configureTestingModule({\n            // Import the HttpClient mocking services\n            imports: [HttpClientTestingModule],\n            // Provide the service-under-test\n            providers: [HeroService]\n        });\n        // Inject the http, test controller, and service-under-test\n        // as they will be referenced by each test.\n        httpClient = TestBed.inject(HttpClient);\n        httpTestingController = TestBed.inject(HttpTestingController);\n        heroService = TestBed.inject(HeroService);\n    });\n    afterEach(() => {\n        // After every test, assert that there are no more pending requests.\n        httpTestingController.verify();\n    });\n    /// HeroService method tests begin ///\n    describe('#getHeroes', () => {\n        let expectedHeroes;\n        beforeEach(() => {\n            heroService = TestBed.inject(HeroService);\n            expectedHeroes = [\n                { id: 1, name: 'A' },\n                { id: 2, name: 'B' },\n            ];\n        });\n        it('should return expected heroes (called once)', () => {\n            heroService.getHeroes().subscribe(heroes => expect(heroes).toEqual(expectedHeroes, 'should return expected heroes'), fail);\n            // HeroService should have made one request to GET heroes from expected URL\n            const req = httpTestingController.expectOne(heroService.heroesUrl);\n            expect(req.request.method).toEqual('GET');\n            // Respond with the mock heroes\n            req.flush(expectedHeroes);\n        });\n        it('should be OK returning no heroes', () => {\n            heroService.getHeroes().subscribe(heroes => expect(heroes.length).toEqual(0, 'should have empty heroes array'), fail);\n            const req = httpTestingController.expectOne(heroService.heroesUrl);\n            req.flush([]); // Respond with no heroes\n        });\n        it('should turn 404 into a user-friendly error', () => {\n            const msg = 'Deliberate 404';\n            heroService.getHeroes().subscribe(heroes => fail('expected to fail'), error => expect(error.message).toContain(msg));\n            const req = httpTestingController.expectOne(heroService.heroesUrl);\n            // respond with a 404 and the error message in the body\n            req.flush(msg, { status: 404, statusText: 'Not Found' });\n        });\n        it('should return expected heroes (called multiple times)', () => {\n            heroService.getHeroes().subscribe();\n            heroService.getHeroes().subscribe();\n            heroService.getHeroes().subscribe(heroes => expect(heroes).toEqual(expectedHeroes, 'should return expected heroes'), fail);\n            const requests = httpTestingController.match(heroService.heroesUrl);\n            expect(requests.length).toEqual(3, 'calls to getHeroes()');\n            // Respond to each request with different mock hero results\n            requests[0].flush([]);\n            requests[1].flush([{ id: 1, name: 'bob' }]);\n            requests[2].flush(expectedHeroes);\n        });\n    });\n    describe('#updateHero', () => {\n        // Expecting the query form of URL so should not 404 when id not found\n        const makeUrl = (id) => `${heroService.heroesUrl}/?id=${id}`;\n        it('should update a hero and return it', () => {\n            const updateHero = { id: 1, name: 'A' };\n            heroService.updateHero(updateHero).subscribe(data => expect(data).toEqual(updateHero, 'should return the hero'), fail);\n            // HeroService should have made one request to PUT hero\n            const req = httpTestingController.expectOne(heroService.heroesUrl);\n            expect(req.request.method).toEqual('PUT');\n            expect(req.request.body).toEqual(updateHero);\n            // Expect server to return the hero after PUT\n            const expectedResponse = new HttpResponse({ status: 200, statusText: 'OK', body: updateHero });\n            req.event(expectedResponse);\n        });\n        it('should turn 404 error into user-facing error', () => {\n            const msg = 'Deliberate 404';\n            const updateHero = { id: 1, name: 'A' };\n            heroService.updateHero(updateHero).subscribe(heroes => fail('expected to fail'), error => expect(error.message).toContain(msg));\n            const req = httpTestingController.expectOne(heroService.heroesUrl);\n            // respond with a 404 and the error message in the body\n            req.flush(msg, { status: 404, statusText: 'Not Found' });\n        });\n        it('should turn network error into user-facing error', done => {\n            // Create mock ProgressEvent with type `error`, raised when something goes wrong at\n            // the network level. Connection timeout, DNS error, offline, etc.\n            const errorEvent = new ProgressEvent('error');\n            const updateHero = { id: 1, name: 'A' };\n            heroService.updateHero(updateHero).subscribe(heroes => fail('expected to fail'), error => {\n                expect(error).toBe(errorEvent);\n                done();\n            });\n            const req = httpTestingController.expectOne(heroService.heroesUrl);\n            // Respond with mock error\n            req.error(errorEvent);\n        });\n    });\n    // TODO: test other HeroService methods\n});\n"]},"metadata":{},"sourceType":"module"}