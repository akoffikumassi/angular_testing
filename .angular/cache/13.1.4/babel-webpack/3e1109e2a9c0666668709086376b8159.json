{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { DemoModule, BankAccountComponent, BankAccountParentComponent, LightswitchComponent, Child1Component, Child2Component, Child3Component, MasterService, ValueService, ExternalTemplateComponent, InputComponent, IoComponent, IoParentComponent, MyIfComponent, MyIfChildComponent, MyIfParentComponent, NeedsContentComponent, ParentComponent, TestProvidersComponent, TestViewProvidersComponent, ReversePipeComponent, ShellComponent } from './demo';\nimport { By } from '@angular/platform-browser';\nimport { Component, Injectable } from '@angular/core';\nimport { FormsModule } from '@angular/forms'; // Forms symbols imported only for a specific test below\n\nimport { NgModel, NgControl } from '@angular/forms';\nimport { fakeAsync, inject, TestBed, tick, waitForAsync } from '@angular/core/testing';\nimport { addMatchers, click } from '../../testing';\nexport class NotProvided extends ValueService {}\nbeforeEach(addMatchers);\ndescribe('demo (with TestBed):', () => {\n  ////////  Service Tests  /////////////\n  describe('ValueService', () => {\n    let service;\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        providers: [ValueService]\n      });\n      service = TestBed.inject(ValueService);\n    });\n    it('should use ValueService', () => {\n      service = TestBed.inject(ValueService);\n      expect(service.getValue()).toBe('real value');\n    });\n    it('can inject a default value when service is not provided', () => {\n      expect(TestBed.inject(NotProvided, null)).toBeNull();\n    });\n    it('test should wait for ValueService.getPromiseValue', waitForAsync(() => {\n      service.getPromiseValue().then(value => expect(value).toBe('promise value'));\n    }));\n    it('test should wait for ValueService.getObservableValue', waitForAsync(() => {\n      service.getObservableValue().subscribe(value => expect(value).toBe('observable value'));\n    })); // Must use done. See https://github.com/angular/angular/issues/10127\n\n    it('test should wait for ValueService.getObservableDelayValue', done => {\n      service.getObservableDelayValue().subscribe(value => {\n        expect(value).toBe('observable delay value');\n        done();\n      });\n    });\n    it('should allow the use of fakeAsync', fakeAsync(() => {\n      let value;\n      service.getPromiseValue().then(val => value = val);\n      tick(); // Trigger JS engine cycle until all promises resolve.\n\n      expect(value).toBe('promise value');\n    }));\n  });\n  describe('MasterService', () => {\n    let masterService;\n    let valueServiceSpy;\n    beforeEach(() => {\n      const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n      TestBed.configureTestingModule({\n        // Provide both the service-to-test and its (spy) dependency\n        providers: [MasterService, {\n          provide: ValueService,\n          useValue: spy\n        }]\n      }); // Inject both the service-to-test and its (spy) dependency\n\n      masterService = TestBed.inject(MasterService);\n      valueServiceSpy = TestBed.inject(ValueService);\n    });\n    it('#getValue should return stubbed value from a spy', () => {\n      const stubValue = 'stub value';\n      valueServiceSpy.getValue.and.returnValue(stubValue);\n      expect(masterService.getValue()).toBe(stubValue, 'service returned stub value');\n      expect(valueServiceSpy.getValue.calls.count()).toBe(1, 'spy method was called once');\n      expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue);\n    });\n  });\n  describe('use inject within `it`', () => {\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        providers: [ValueService]\n      });\n    });\n    it('should use modified providers', inject([ValueService], service => {\n      service.setValue('value modified in beforeEach');\n      expect(service.getValue()).toBe('value modified in beforeEach');\n    }));\n  });\n  describe('using waitForAsync(inject) within beforeEach', () => {\n    let serviceValue;\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        providers: [ValueService]\n      });\n    });\n    beforeEach(waitForAsync(inject([ValueService], service => {\n      service.getPromiseValue().then(value => serviceValue = value);\n    })));\n    it('should use asynchronously modified value ... in synchronous test', () => {\n      expect(serviceValue).toBe('promise value');\n    });\n  }); /////////// Component Tests //////////////////\n\n  describe('TestBed component tests', () => {\n    beforeEach(waitForAsync(() => {\n      TestBed.configureTestingModule({\n        imports: [DemoModule]\n      }) // Compile everything in DemoModule\n      .compileComponents();\n    }));\n    it('should create a component with inline template', () => {\n      const fixture = TestBed.createComponent(Child1Component);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Child');\n    });\n    it('should create a component with external template', () => {\n      const fixture = TestBed.createComponent(ExternalTemplateComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('from external template');\n    });\n    it('should allow changing members of the component', () => {\n      const fixture = TestBed.createComponent(MyIfComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('MyIf()');\n      fixture.componentInstance.showMore = true;\n      fixture.detectChanges();\n      expect(fixture).toHaveText('MyIf(More)');\n    });\n    it('should create a nested component bound to inputs/outputs', () => {\n      const fixture = TestBed.createComponent(IoParentComponent);\n      fixture.detectChanges();\n      const heroes = fixture.debugElement.queryAll(By.css('.hero'));\n      expect(heroes.length).toBeGreaterThan(0, 'has heroes');\n      const comp = fixture.componentInstance;\n      const hero = comp.heroes[0];\n      click(heroes[0]);\n      fixture.detectChanges();\n      const selected = fixture.debugElement.query(By.css('p'));\n      expect(selected).toHaveText(hero.name);\n    });\n    it('can access the instance variable of an `*ngFor` row component', () => {\n      const fixture = TestBed.createComponent(IoParentComponent);\n      const comp = fixture.componentInstance;\n      const heroName = comp.heroes[0].name; // first hero's name\n\n      fixture.detectChanges();\n      const ngForRow = fixture.debugElement.query(By.directive(IoComponent)); // first hero ngForRow\n\n      const hero = ngForRow.context.hero; // the hero object passed into the row\n\n      expect(hero.name).toBe(heroName, 'ngRow.context.hero');\n      const rowComp = ngForRow.componentInstance; // jasmine.any is an \"instance-of-type\" test.\n\n      expect(rowComp).toEqual(jasmine.any(IoComponent), 'component is IoComp');\n      expect(rowComp.hero.name).toBe(heroName, 'component.hero');\n    });\n    it('should support clicking a button', () => {\n      const fixture = TestBed.createComponent(LightswitchComponent);\n      const btn = fixture.debugElement.query(By.css('button'));\n      const span = fixture.debugElement.query(By.css('span')).nativeElement;\n      fixture.detectChanges();\n      expect(span.textContent).toMatch(/is off/i, 'before click');\n      click(btn);\n      fixture.detectChanges();\n      expect(span.textContent).toMatch(/is on/i, 'after click');\n    }); // ngModel is async so we must wait for it with promise-based `whenStable`\n\n    it('should support entering text in input box (ngModel)', waitForAsync(() => {\n      const expectedOrigName = 'John';\n      const expectedNewName = 'Sally';\n      const fixture = TestBed.createComponent(InputComponent);\n      fixture.detectChanges();\n      const comp = fixture.componentInstance;\n      const input = fixture.debugElement.query(By.css('input')).nativeElement;\n      expect(comp.name).toBe(expectedOrigName, `At start name should be ${expectedOrigName} `); // wait until ngModel binds comp.name to input box\n\n      fixture.whenStable().then(() => {\n        expect(input.value).toBe(expectedOrigName, `After ngModel updates input box, input.value should be ${expectedOrigName} `); // simulate user entering new name in input\n\n        input.value = expectedNewName; // that change doesn't flow to the component immediately\n\n        expect(comp.name).toBe(expectedOrigName, `comp.name should still be ${expectedOrigName} after value change, before binding happens`); // Dispatch a DOM event so that Angular learns of input value change.\n        // then wait while ngModel pushes input.box value to comp.name\n        // In older browsers, such as IE, you might need a CustomEvent instead. See\n        // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n\n        input.dispatchEvent(new Event('input'));\n        return fixture.whenStable();\n      }).then(() => {\n        expect(comp.name).toBe(expectedNewName, `After ngModel updates the model, comp.name should be ${expectedNewName} `);\n      });\n    })); // fakeAsync version of ngModel input test enables sync test style\n    // synchronous `tick` replaces asynchronous promise-base `whenStable`\n\n    it('should support entering text in input box (ngModel) - fakeAsync', fakeAsync(() => {\n      const expectedOrigName = 'John';\n      const expectedNewName = 'Sally';\n      const fixture = TestBed.createComponent(InputComponent);\n      fixture.detectChanges();\n      const comp = fixture.componentInstance;\n      const input = fixture.debugElement.query(By.css('input')).nativeElement;\n      expect(comp.name).toBe(expectedOrigName, `At start name should be ${expectedOrigName} `); // wait until ngModel binds comp.name to input box\n\n      tick();\n      expect(input.value).toBe(expectedOrigName, `After ngModel updates input box, input.value should be ${expectedOrigName} `); // simulate user entering new name in input\n\n      input.value = expectedNewName; // that change doesn't flow to the component immediately\n\n      expect(comp.name).toBe(expectedOrigName, `comp.name should still be ${expectedOrigName} after value change, before binding happens`); // Dispatch a DOM event so that Angular learns of input value change.\n      // then wait a tick while ngModel pushes input.box value to comp.name\n      // In older browsers, such as IE, you might need a CustomEvent instead. See\n      // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n\n      input.dispatchEvent(new Event('input'));\n      tick();\n      expect(comp.name).toBe(expectedNewName, `After ngModel updates the model, comp.name should be ${expectedNewName} `);\n    }));\n    it('ReversePipeComp should reverse the input text', fakeAsync(() => {\n      const inputText = 'the quick brown fox.';\n      const expectedText = '.xof nworb kciuq eht';\n      const fixture = TestBed.createComponent(ReversePipeComponent);\n      fixture.detectChanges();\n      const comp = fixture.componentInstance;\n      const input = fixture.debugElement.query(By.css('input')).nativeElement;\n      const span = fixture.debugElement.query(By.css('span')).nativeElement; // simulate user entering new name in input\n\n      input.value = inputText; // Dispatch a DOM event so that Angular learns of input value change.\n      // then wait a tick while ngModel pushes input.box value to comp.text\n      // and Angular updates the output span\n      // In older browsers, such as IE, you might need a CustomEvent instead. See\n      // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n\n      input.dispatchEvent(new Event('input'));\n      tick();\n      fixture.detectChanges();\n      expect(span.textContent).toBe(expectedText, 'output span');\n      expect(comp.text).toBe(inputText, 'component.text');\n    })); // Use this technique to find attached directives of any kind\n\n    it('can examine attached directives and listeners', () => {\n      const fixture = TestBed.createComponent(InputComponent);\n      fixture.detectChanges();\n      const inputEl = fixture.debugElement.query(By.css('input'));\n      expect(inputEl.providerTokens).toContain(NgModel, 'NgModel directive');\n      const ngControl = inputEl.injector.get(NgControl);\n      expect(ngControl).toEqual(jasmine.any(NgControl), 'NgControl directive');\n      expect(inputEl.listeners.length).toBeGreaterThan(2, 'several listeners attached');\n    });\n    it('BankAccountComponent should set attributes, styles, classes, and properties', () => {\n      const fixture = TestBed.createComponent(BankAccountParentComponent);\n      fixture.detectChanges();\n      const comp = fixture.componentInstance; // the only child is debugElement of the BankAccount component\n\n      const el = fixture.debugElement.children[0];\n      const childComp = el.componentInstance;\n      expect(childComp).toEqual(jasmine.any(BankAccountComponent));\n      expect(el.context).toBe(childComp, 'context is the child component');\n      expect(el.attributes['account']).toBe(childComp.id, 'account attribute');\n      expect(el.attributes['bank']).toBe(childComp.bank, 'bank attribute');\n      expect(el.classes['closed']).toBe(true, 'closed class');\n      expect(el.classes['open']).toBeFalsy('open class');\n      expect(el.styles['color']).toBe(comp.color, 'color style');\n      expect(el.styles['width']).toBe(comp.width + 'px', 'width style'); // Removed on 12/02/2016 when ceased public discussion of the `Renderer`. Revive in future?\n      // expect(el.properties['customProperty']).toBe(true, 'customProperty');\n    });\n  });\n  describe('TestBed component overrides:', () => {\n    it('should override ChildComp\\'s template', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [Child1Component]\n      }).overrideComponent(Child1Component, {\n        set: {\n          template: '<span>Fake</span>'\n        }\n      }).createComponent(Child1Component);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Fake');\n    });\n    it('should override TestProvidersComp\\'s ValueService provider', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [TestProvidersComponent]\n      }).overrideComponent(TestProvidersComponent, {\n        remove: {\n          providers: [ValueService]\n        },\n        add: {\n          providers: [{\n            provide: ValueService,\n            useClass: FakeValueService\n          }]\n        } // Or replace them all (this component has only one provider)\n        // set:    { providers: [{ provide: ValueService, useClass: FakeValueService }] },\n\n      }).createComponent(TestProvidersComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('injected value: faked value', 'text'); // Explore the providerTokens\n\n      const tokens = fixture.debugElement.providerTokens;\n      expect(tokens).toContain(fixture.componentInstance.constructor, 'component ctor');\n      expect(tokens).toContain(TestProvidersComponent, 'TestProvidersComp');\n      expect(tokens).toContain(ValueService, 'ValueService');\n    });\n    it('should override TestViewProvidersComp\\'s ValueService viewProvider', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [TestViewProvidersComponent]\n      }).overrideComponent(TestViewProvidersComponent, {\n        // remove: { viewProviders: [ValueService]},\n        // add:    { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] },\n        // Or replace them all (this component has only one viewProvider)\n        set: {\n          viewProviders: [{\n            provide: ValueService,\n            useClass: FakeValueService\n          }]\n        }\n      }).createComponent(TestViewProvidersComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('injected value: faked value');\n    });\n    it('injected provider should not be same as component\\'s provider', () => {\n      // TestComponent is parent of TestProvidersComponent\n      let TestComponent = class TestComponent {};\n      TestComponent = __decorate([Component({\n        template: '<my-service-comp></my-service-comp>'\n      })], TestComponent); // 3 levels of ValueService provider: module, TestCompomponent, TestProvidersComponent\n\n      const fixture = TestBed.configureTestingModule({\n        declarations: [TestComponent, TestProvidersComponent],\n        providers: [ValueService]\n      }).overrideComponent(TestComponent, {\n        set: {\n          providers: [{\n            provide: ValueService,\n            useValue: {}\n          }]\n        }\n      }).overrideComponent(TestProvidersComponent, {\n        set: {\n          providers: [{\n            provide: ValueService,\n            useClass: FakeValueService\n          }]\n        }\n      }).createComponent(TestComponent);\n      let testBedProvider;\n      let tcProvider;\n      let tpcProvider; // `inject` uses TestBed's injector\n\n      inject([ValueService], s => testBedProvider = s)();\n      tcProvider = fixture.debugElement.injector.get(ValueService);\n      tpcProvider = fixture.debugElement.children[0].injector.get(ValueService);\n      expect(testBedProvider).not.toBe(tcProvider, 'testBed/tc not same providers');\n      expect(testBedProvider).not.toBe(tpcProvider, 'testBed/tpc not same providers');\n      expect(testBedProvider instanceof ValueService).toBe(true, 'testBedProvider is ValueService');\n      expect(tcProvider).toEqual({}, 'tcProvider is {}');\n      expect(tpcProvider instanceof FakeValueService).toBe(true, 'tpcProvider is FakeValueService');\n    });\n    it('can access template local variables as references', () => {\n      const fixture = TestBed.configureTestingModule({\n        declarations: [ShellComponent, NeedsContentComponent, Child1Component, Child2Component, Child3Component]\n      }).overrideComponent(ShellComponent, {\n        set: {\n          selector: 'test-shell',\n          template: `\n          <needs-content #nc>\n            <child-1 #content text=\"My\"></child-1>\n            <child-2 #content text=\"dog\"></child-2>\n            <child-2 text=\"has\"></child-2>\n            <child-3 #content text=\"fleas\"></child-3>\n            <div #content>!</div>\n          </needs-content>\n          `\n        }\n      }).createComponent(ShellComponent);\n      fixture.detectChanges(); // NeedsContentComp is the child of ShellComp\n\n      const el = fixture.debugElement.children[0];\n      const comp = el.componentInstance;\n      expect(comp.children.toArray().length).toBe(4, 'three different child components and an ElementRef with #content');\n      expect(el.references['nc']).toBe(comp, '#nc reference to component'); // Filter for DebugElements with a #content reference\n\n      const contentRefs = el.queryAll(de => de.references['content']);\n      expect(contentRefs.length).toBe(4, 'elements w/ a #content reference');\n    });\n  });\n  describe('nested (one-deep) component override', () => {\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [ParentComponent, FakeChildComponent]\n      });\n    });\n    it('ParentComp should use Fake Child component', () => {\n      const fixture = TestBed.createComponent(ParentComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Parent(Fake Child)');\n    });\n  });\n  describe('nested (two-deep) component override', () => {\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [ParentComponent, FakeChildWithGrandchildComponent, FakeGrandchildComponent]\n      });\n    });\n    it('should use Fake Grandchild component', () => {\n      const fixture = TestBed.createComponent(ParentComponent);\n      fixture.detectChanges();\n      expect(fixture).toHaveText('Parent(Fake Child(Fake Grandchild))');\n    });\n  });\n  describe('lifecycle hooks w/ MyIfParentComp', () => {\n    let fixture;\n    let parent;\n    let child;\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        imports: [FormsModule],\n        declarations: [MyIfChildComponent, MyIfParentComponent]\n      });\n      fixture = TestBed.createComponent(MyIfParentComponent);\n      parent = fixture.componentInstance;\n    });\n    it('should instantiate parent component', () => {\n      expect(parent).not.toBeNull('parent component should exist');\n    });\n    it('parent component OnInit should NOT be called before first detectChanges()', () => {\n      expect(parent.ngOnInitCalled).toBe(false);\n    });\n    it('parent component OnInit should be called after first detectChanges()', () => {\n      fixture.detectChanges();\n      expect(parent.ngOnInitCalled).toBe(true);\n    });\n    it('child component should exist after OnInit', () => {\n      fixture.detectChanges();\n      getChild();\n      expect(child instanceof MyIfChildComponent).toBe(true, 'should create child');\n    });\n    it('should have called child component\\'s OnInit ', () => {\n      fixture.detectChanges();\n      getChild();\n      expect(child.ngOnInitCalled).toBe(true);\n    });\n    it('child component called OnChanges once', () => {\n      fixture.detectChanges();\n      getChild();\n      expect(child.ngOnChangesCounter).toBe(1);\n    });\n    it('changed parent value flows to child', () => {\n      fixture.detectChanges();\n      getChild();\n      parent.parentValue = 'foo';\n      fixture.detectChanges();\n      expect(child.ngOnChangesCounter).toBe(2, 'expected 2 changes: initial value and changed value');\n      expect(child.childValue).toBe('foo', 'childValue should eq changed parent value');\n    }); // must be async test to see child flow to parent\n\n    it('changed child value flows to parent', waitForAsync(() => {\n      fixture.detectChanges();\n      getChild();\n      child.childValue = 'bar';\n      return new Promise(resolve => {\n        // Wait one JS engine turn!\n        setTimeout(() => resolve(), 0);\n      }).then(() => {\n        fixture.detectChanges();\n        expect(child.ngOnChangesCounter).toBe(2, 'expected 2 changes: initial value and changed value');\n        expect(parent.parentValue).toBe('bar', 'parentValue should eq changed parent value');\n      });\n    }));\n    it('clicking \"Close Child\" triggers child OnDestroy', () => {\n      fixture.detectChanges();\n      getChild();\n      const btn = fixture.debugElement.query(By.css('button'));\n      click(btn);\n      fixture.detectChanges();\n      expect(child.ngOnDestroyCalled).toBe(true);\n    }); ////// helpers ///\n\n    /**\n     * Get the MyIfChildComp from parent; fail w/ good message if cannot.\n     */\n\n    function getChild() {\n      let childDe; // DebugElement that should hold the MyIfChildComp\n      // The Hard Way: requires detailed knowledge of the parent template\n\n      try {\n        childDe = fixture.debugElement.children[4].children[0];\n      } catch (err) {\n        /* we'll report the error */\n      } // DebugElement.queryAll: if we wanted all of many instances:\n\n\n      childDe = fixture.debugElement.queryAll(de => de.componentInstance instanceof MyIfChildComponent)[0]; // WE'LL USE THIS APPROACH !\n      // DebugElement.query: find first instance (if any)\n\n      childDe = fixture.debugElement.query(de => de.componentInstance instanceof MyIfChildComponent);\n\n      if (childDe && childDe.componentInstance) {\n        child = childDe.componentInstance;\n      } else {\n        fail('Unable to find MyIfChildComp within MyIfParentComp');\n      }\n\n      return child;\n    }\n  });\n}); ////////// Fakes ///////////\n\nlet FakeChildComponent = class FakeChildComponent {};\nFakeChildComponent = __decorate([Component({\n  selector: 'child-1',\n  template: `Fake Child`\n})], FakeChildComponent);\nlet FakeChildWithGrandchildComponent = class FakeChildWithGrandchildComponent {};\nFakeChildWithGrandchildComponent = __decorate([Component({\n  selector: 'child-1',\n  template: `Fake Child(<grandchild-1></grandchild-1>)`\n})], FakeChildWithGrandchildComponent);\nlet FakeGrandchildComponent = class FakeGrandchildComponent {};\nFakeGrandchildComponent = __decorate([Component({\n  selector: 'grandchild-1',\n  template: `Fake Grandchild`\n})], FakeGrandchildComponent);\nlet FakeValueService = class FakeValueService extends ValueService {\n  constructor() {\n    super(...arguments);\n    this.value = 'faked value';\n  }\n\n};\nFakeValueService = __decorate([Injectable()], FakeValueService);","map":{"version":3,"sources":["/home/yadadev/work/trainings/mean/angular/angular_testing/src/app/demo/demo.testbed.spec.ts"],"names":["__decorate","DemoModule","BankAccountComponent","BankAccountParentComponent","LightswitchComponent","Child1Component","Child2Component","Child3Component","MasterService","ValueService","ExternalTemplateComponent","InputComponent","IoComponent","IoParentComponent","MyIfComponent","MyIfChildComponent","MyIfParentComponent","NeedsContentComponent","ParentComponent","TestProvidersComponent","TestViewProvidersComponent","ReversePipeComponent","ShellComponent","By","Component","Injectable","FormsModule","NgModel","NgControl","fakeAsync","inject","TestBed","tick","waitForAsync","addMatchers","click","NotProvided","beforeEach","describe","service","configureTestingModule","providers","it","expect","getValue","toBe","toBeNull","getPromiseValue","then","value","getObservableValue","subscribe","done","getObservableDelayValue","val","masterService","valueServiceSpy","spy","jasmine","createSpyObj","provide","useValue","stubValue","and","returnValue","calls","count","mostRecent","setValue","serviceValue","imports","compileComponents","fixture","createComponent","detectChanges","toHaveText","componentInstance","showMore","heroes","debugElement","queryAll","css","length","toBeGreaterThan","comp","hero","selected","query","name","heroName","ngForRow","directive","context","rowComp","toEqual","any","btn","span","nativeElement","textContent","toMatch","expectedOrigName","expectedNewName","input","whenStable","dispatchEvent","Event","inputText","expectedText","text","inputEl","providerTokens","toContain","ngControl","injector","get","listeners","el","children","childComp","attributes","id","bank","classes","toBeFalsy","styles","color","width","declarations","overrideComponent","set","template","remove","add","useClass","FakeValueService","tokens","constructor","viewProviders","TestComponent","testBedProvider","tcProvider","tpcProvider","s","not","selector","toArray","references","contentRefs","de","FakeChildComponent","FakeChildWithGrandchildComponent","FakeGrandchildComponent","parent","child","ngOnInitCalled","getChild","ngOnChangesCounter","parentValue","childValue","Promise","resolve","setTimeout","ngOnDestroyCalled","childDe","err","fail","arguments"],"mappings":"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","sourcesContent":["import { __decorate } from \"tslib\";\nimport { DemoModule, BankAccountComponent, BankAccountParentComponent, LightswitchComponent, Child1Component, Child2Component, Child3Component, MasterService, ValueService, ExternalTemplateComponent, InputComponent, IoComponent, IoParentComponent, MyIfComponent, MyIfChildComponent, MyIfParentComponent, NeedsContentComponent, ParentComponent, TestProvidersComponent, TestViewProvidersComponent, ReversePipeComponent, ShellComponent } from './demo';\nimport { By } from '@angular/platform-browser';\nimport { Component, Injectable } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n// Forms symbols imported only for a specific test below\nimport { NgModel, NgControl } from '@angular/forms';\nimport { fakeAsync, inject, TestBed, tick, waitForAsync } from '@angular/core/testing';\nimport { addMatchers, click } from '../../testing';\nexport class NotProvided extends ValueService {\n}\nbeforeEach(addMatchers);\ndescribe('demo (with TestBed):', () => {\n    ////////  Service Tests  /////////////\n    describe('ValueService', () => {\n        let service;\n        beforeEach(() => {\n            TestBed.configureTestingModule({ providers: [ValueService] });\n            service = TestBed.inject(ValueService);\n        });\n        it('should use ValueService', () => {\n            service = TestBed.inject(ValueService);\n            expect(service.getValue()).toBe('real value');\n        });\n        it('can inject a default value when service is not provided', () => {\n            expect(TestBed.inject(NotProvided, null)).toBeNull();\n        });\n        it('test should wait for ValueService.getPromiseValue', waitForAsync(() => {\n            service.getPromiseValue().then(value => expect(value).toBe('promise value'));\n        }));\n        it('test should wait for ValueService.getObservableValue', waitForAsync(() => {\n            service.getObservableValue().subscribe(value => expect(value).toBe('observable value'));\n        }));\n        // Must use done. See https://github.com/angular/angular/issues/10127\n        it('test should wait for ValueService.getObservableDelayValue', (done) => {\n            service.getObservableDelayValue().subscribe(value => {\n                expect(value).toBe('observable delay value');\n                done();\n            });\n        });\n        it('should allow the use of fakeAsync', fakeAsync(() => {\n            let value;\n            service.getPromiseValue().then((val) => value = val);\n            tick(); // Trigger JS engine cycle until all promises resolve.\n            expect(value).toBe('promise value');\n        }));\n    });\n    describe('MasterService', () => {\n        let masterService;\n        let valueServiceSpy;\n        beforeEach(() => {\n            const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n            TestBed.configureTestingModule({\n                // Provide both the service-to-test and its (spy) dependency\n                providers: [\n                    MasterService,\n                    { provide: ValueService, useValue: spy }\n                ]\n            });\n            // Inject both the service-to-test and its (spy) dependency\n            masterService = TestBed.inject(MasterService);\n            valueServiceSpy = TestBed.inject(ValueService);\n        });\n        it('#getValue should return stubbed value from a spy', () => {\n            const stubValue = 'stub value';\n            valueServiceSpy.getValue.and.returnValue(stubValue);\n            expect(masterService.getValue())\n                .toBe(stubValue, 'service returned stub value');\n            expect(valueServiceSpy.getValue.calls.count())\n                .toBe(1, 'spy method was called once');\n            expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n                .toBe(stubValue);\n        });\n    });\n    describe('use inject within `it`', () => {\n        beforeEach(() => {\n            TestBed.configureTestingModule({ providers: [ValueService] });\n        });\n        it('should use modified providers', inject([ValueService], (service) => {\n            service.setValue('value modified in beforeEach');\n            expect(service.getValue())\n                .toBe('value modified in beforeEach');\n        }));\n    });\n    describe('using waitForAsync(inject) within beforeEach', () => {\n        let serviceValue;\n        beforeEach(() => {\n            TestBed.configureTestingModule({ providers: [ValueService] });\n        });\n        beforeEach(waitForAsync(inject([ValueService], (service) => {\n            service.getPromiseValue().then(value => serviceValue = value);\n        })));\n        it('should use asynchronously modified value ... in synchronous test', () => {\n            expect(serviceValue).toBe('promise value');\n        });\n    });\n    /////////// Component Tests //////////////////\n    describe('TestBed component tests', () => {\n        beforeEach(waitForAsync(() => {\n            TestBed\n                .configureTestingModule({\n                imports: [DemoModule],\n            })\n                // Compile everything in DemoModule\n                .compileComponents();\n        }));\n        it('should create a component with inline template', () => {\n            const fixture = TestBed.createComponent(Child1Component);\n            fixture.detectChanges();\n            expect(fixture).toHaveText('Child');\n        });\n        it('should create a component with external template', () => {\n            const fixture = TestBed.createComponent(ExternalTemplateComponent);\n            fixture.detectChanges();\n            expect(fixture).toHaveText('from external template');\n        });\n        it('should allow changing members of the component', () => {\n            const fixture = TestBed.createComponent(MyIfComponent);\n            fixture.detectChanges();\n            expect(fixture).toHaveText('MyIf()');\n            fixture.componentInstance.showMore = true;\n            fixture.detectChanges();\n            expect(fixture).toHaveText('MyIf(More)');\n        });\n        it('should create a nested component bound to inputs/outputs', () => {\n            const fixture = TestBed.createComponent(IoParentComponent);\n            fixture.detectChanges();\n            const heroes = fixture.debugElement.queryAll(By.css('.hero'));\n            expect(heroes.length).toBeGreaterThan(0, 'has heroes');\n            const comp = fixture.componentInstance;\n            const hero = comp.heroes[0];\n            click(heroes[0]);\n            fixture.detectChanges();\n            const selected = fixture.debugElement.query(By.css('p'));\n            expect(selected).toHaveText(hero.name);\n        });\n        it('can access the instance variable of an `*ngFor` row component', () => {\n            const fixture = TestBed.createComponent(IoParentComponent);\n            const comp = fixture.componentInstance;\n            const heroName = comp.heroes[0].name; // first hero's name\n            fixture.detectChanges();\n            const ngForRow = fixture.debugElement.query(By.directive(IoComponent)); // first hero ngForRow\n            const hero = ngForRow.context.hero; // the hero object passed into the row\n            expect(hero.name).toBe(heroName, 'ngRow.context.hero');\n            const rowComp = ngForRow.componentInstance;\n            // jasmine.any is an \"instance-of-type\" test.\n            expect(rowComp).toEqual(jasmine.any(IoComponent), 'component is IoComp');\n            expect(rowComp.hero.name).toBe(heroName, 'component.hero');\n        });\n        it('should support clicking a button', () => {\n            const fixture = TestBed.createComponent(LightswitchComponent);\n            const btn = fixture.debugElement.query(By.css('button'));\n            const span = fixture.debugElement.query(By.css('span')).nativeElement;\n            fixture.detectChanges();\n            expect(span.textContent).toMatch(/is off/i, 'before click');\n            click(btn);\n            fixture.detectChanges();\n            expect(span.textContent).toMatch(/is on/i, 'after click');\n        });\n        // ngModel is async so we must wait for it with promise-based `whenStable`\n        it('should support entering text in input box (ngModel)', waitForAsync(() => {\n            const expectedOrigName = 'John';\n            const expectedNewName = 'Sally';\n            const fixture = TestBed.createComponent(InputComponent);\n            fixture.detectChanges();\n            const comp = fixture.componentInstance;\n            const input = fixture.debugElement.query(By.css('input')).nativeElement;\n            expect(comp.name).toBe(expectedOrigName, `At start name should be ${expectedOrigName} `);\n            // wait until ngModel binds comp.name to input box\n            fixture.whenStable().then(() => {\n                expect(input.value).toBe(expectedOrigName, `After ngModel updates input box, input.value should be ${expectedOrigName} `);\n                // simulate user entering new name in input\n                input.value = expectedNewName;\n                // that change doesn't flow to the component immediately\n                expect(comp.name).toBe(expectedOrigName, `comp.name should still be ${expectedOrigName} after value change, before binding happens`);\n                // Dispatch a DOM event so that Angular learns of input value change.\n                // then wait while ngModel pushes input.box value to comp.name\n                // In older browsers, such as IE, you might need a CustomEvent instead. See\n                // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n                input.dispatchEvent(new Event('input'));\n                return fixture.whenStable();\n            })\n                .then(() => {\n                expect(comp.name).toBe(expectedNewName, `After ngModel updates the model, comp.name should be ${expectedNewName} `);\n            });\n        }));\n        // fakeAsync version of ngModel input test enables sync test style\n        // synchronous `tick` replaces asynchronous promise-base `whenStable`\n        it('should support entering text in input box (ngModel) - fakeAsync', fakeAsync(() => {\n            const expectedOrigName = 'John';\n            const expectedNewName = 'Sally';\n            const fixture = TestBed.createComponent(InputComponent);\n            fixture.detectChanges();\n            const comp = fixture.componentInstance;\n            const input = fixture.debugElement.query(By.css('input')).nativeElement;\n            expect(comp.name).toBe(expectedOrigName, `At start name should be ${expectedOrigName} `);\n            // wait until ngModel binds comp.name to input box\n            tick();\n            expect(input.value).toBe(expectedOrigName, `After ngModel updates input box, input.value should be ${expectedOrigName} `);\n            // simulate user entering new name in input\n            input.value = expectedNewName;\n            // that change doesn't flow to the component immediately\n            expect(comp.name).toBe(expectedOrigName, `comp.name should still be ${expectedOrigName} after value change, before binding happens`);\n            // Dispatch a DOM event so that Angular learns of input value change.\n            // then wait a tick while ngModel pushes input.box value to comp.name\n            // In older browsers, such as IE, you might need a CustomEvent instead. See\n            // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n            input.dispatchEvent(new Event('input'));\n            tick();\n            expect(comp.name).toBe(expectedNewName, `After ngModel updates the model, comp.name should be ${expectedNewName} `);\n        }));\n        it('ReversePipeComp should reverse the input text', fakeAsync(() => {\n            const inputText = 'the quick brown fox.';\n            const expectedText = '.xof nworb kciuq eht';\n            const fixture = TestBed.createComponent(ReversePipeComponent);\n            fixture.detectChanges();\n            const comp = fixture.componentInstance;\n            const input = fixture.debugElement.query(By.css('input')).nativeElement;\n            const span = fixture.debugElement.query(By.css('span')).nativeElement;\n            // simulate user entering new name in input\n            input.value = inputText;\n            // Dispatch a DOM event so that Angular learns of input value change.\n            // then wait a tick while ngModel pushes input.box value to comp.text\n            // and Angular updates the output span\n            // In older browsers, such as IE, you might need a CustomEvent instead. See\n            // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n            input.dispatchEvent(new Event('input'));\n            tick();\n            fixture.detectChanges();\n            expect(span.textContent).toBe(expectedText, 'output span');\n            expect(comp.text).toBe(inputText, 'component.text');\n        }));\n        // Use this technique to find attached directives of any kind\n        it('can examine attached directives and listeners', () => {\n            const fixture = TestBed.createComponent(InputComponent);\n            fixture.detectChanges();\n            const inputEl = fixture.debugElement.query(By.css('input'));\n            expect(inputEl.providerTokens).toContain(NgModel, 'NgModel directive');\n            const ngControl = inputEl.injector.get(NgControl);\n            expect(ngControl).toEqual(jasmine.any(NgControl), 'NgControl directive');\n            expect(inputEl.listeners.length).toBeGreaterThan(2, 'several listeners attached');\n        });\n        it('BankAccountComponent should set attributes, styles, classes, and properties', () => {\n            const fixture = TestBed.createComponent(BankAccountParentComponent);\n            fixture.detectChanges();\n            const comp = fixture.componentInstance;\n            // the only child is debugElement of the BankAccount component\n            const el = fixture.debugElement.children[0];\n            const childComp = el.componentInstance;\n            expect(childComp).toEqual(jasmine.any(BankAccountComponent));\n            expect(el.context).toBe(childComp, 'context is the child component');\n            expect(el.attributes['account']).toBe(childComp.id, 'account attribute');\n            expect(el.attributes['bank']).toBe(childComp.bank, 'bank attribute');\n            expect(el.classes['closed']).toBe(true, 'closed class');\n            expect(el.classes['open']).toBeFalsy('open class');\n            expect(el.styles['color']).toBe(comp.color, 'color style');\n            expect(el.styles['width']).toBe(comp.width + 'px', 'width style');\n            // Removed on 12/02/2016 when ceased public discussion of the `Renderer`. Revive in future?\n            // expect(el.properties['customProperty']).toBe(true, 'customProperty');\n        });\n    });\n    describe('TestBed component overrides:', () => {\n        it('should override ChildComp\\'s template', () => {\n            const fixture = TestBed.configureTestingModule({\n                declarations: [Child1Component],\n            })\n                .overrideComponent(Child1Component, {\n                set: { template: '<span>Fake</span>' }\n            })\n                .createComponent(Child1Component);\n            fixture.detectChanges();\n            expect(fixture).toHaveText('Fake');\n        });\n        it('should override TestProvidersComp\\'s ValueService provider', () => {\n            const fixture = TestBed.configureTestingModule({\n                declarations: [TestProvidersComponent],\n            })\n                .overrideComponent(TestProvidersComponent, {\n                remove: { providers: [ValueService] },\n                add: { providers: [{ provide: ValueService, useClass: FakeValueService }] },\n                // Or replace them all (this component has only one provider)\n                // set:    { providers: [{ provide: ValueService, useClass: FakeValueService }] },\n            })\n                .createComponent(TestProvidersComponent);\n            fixture.detectChanges();\n            expect(fixture).toHaveText('injected value: faked value', 'text');\n            // Explore the providerTokens\n            const tokens = fixture.debugElement.providerTokens;\n            expect(tokens).toContain(fixture.componentInstance.constructor, 'component ctor');\n            expect(tokens).toContain(TestProvidersComponent, 'TestProvidersComp');\n            expect(tokens).toContain(ValueService, 'ValueService');\n        });\n        it('should override TestViewProvidersComp\\'s ValueService viewProvider', () => {\n            const fixture = TestBed.configureTestingModule({\n                declarations: [TestViewProvidersComponent],\n            })\n                .overrideComponent(TestViewProvidersComponent, {\n                // remove: { viewProviders: [ValueService]},\n                // add:    { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] },\n                // Or replace them all (this component has only one viewProvider)\n                set: { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] },\n            })\n                .createComponent(TestViewProvidersComponent);\n            fixture.detectChanges();\n            expect(fixture).toHaveText('injected value: faked value');\n        });\n        it('injected provider should not be same as component\\'s provider', () => {\n            // TestComponent is parent of TestProvidersComponent\n            let TestComponent = class TestComponent {\n            };\n            TestComponent = __decorate([\n                Component({ template: '<my-service-comp></my-service-comp>' })\n            ], TestComponent);\n            // 3 levels of ValueService provider: module, TestCompomponent, TestProvidersComponent\n            const fixture = TestBed.configureTestingModule({\n                declarations: [TestComponent, TestProvidersComponent],\n                providers: [ValueService]\n            })\n                .overrideComponent(TestComponent, {\n                set: { providers: [{ provide: ValueService, useValue: {} }] }\n            })\n                .overrideComponent(TestProvidersComponent, {\n                set: { providers: [{ provide: ValueService, useClass: FakeValueService }] }\n            })\n                .createComponent(TestComponent);\n            let testBedProvider;\n            let tcProvider;\n            let tpcProvider;\n            // `inject` uses TestBed's injector\n            inject([ValueService], (s) => testBedProvider = s)();\n            tcProvider = fixture.debugElement.injector.get(ValueService);\n            tpcProvider = fixture.debugElement.children[0].injector.get(ValueService);\n            expect(testBedProvider).not.toBe(tcProvider, 'testBed/tc not same providers');\n            expect(testBedProvider).not.toBe(tpcProvider, 'testBed/tpc not same providers');\n            expect(testBedProvider instanceof ValueService).toBe(true, 'testBedProvider is ValueService');\n            expect(tcProvider).toEqual({}, 'tcProvider is {}');\n            expect(tpcProvider instanceof FakeValueService).toBe(true, 'tpcProvider is FakeValueService');\n        });\n        it('can access template local variables as references', () => {\n            const fixture = TestBed.configureTestingModule({\n                declarations: [ShellComponent, NeedsContentComponent, Child1Component, Child2Component, Child3Component],\n            })\n                .overrideComponent(ShellComponent, {\n                set: {\n                    selector: 'test-shell',\n                    template: `\n          <needs-content #nc>\n            <child-1 #content text=\"My\"></child-1>\n            <child-2 #content text=\"dog\"></child-2>\n            <child-2 text=\"has\"></child-2>\n            <child-3 #content text=\"fleas\"></child-3>\n            <div #content>!</div>\n          </needs-content>\n          `\n                }\n            })\n                .createComponent(ShellComponent);\n            fixture.detectChanges();\n            // NeedsContentComp is the child of ShellComp\n            const el = fixture.debugElement.children[0];\n            const comp = el.componentInstance;\n            expect(comp.children.toArray().length).toBe(4, 'three different child components and an ElementRef with #content');\n            expect(el.references['nc']).toBe(comp, '#nc reference to component');\n            // Filter for DebugElements with a #content reference\n            const contentRefs = el.queryAll(de => de.references['content']);\n            expect(contentRefs.length).toBe(4, 'elements w/ a #content reference');\n        });\n    });\n    describe('nested (one-deep) component override', () => {\n        beforeEach(() => {\n            TestBed.configureTestingModule({\n                declarations: [ParentComponent, FakeChildComponent]\n            });\n        });\n        it('ParentComp should use Fake Child component', () => {\n            const fixture = TestBed.createComponent(ParentComponent);\n            fixture.detectChanges();\n            expect(fixture).toHaveText('Parent(Fake Child)');\n        });\n    });\n    describe('nested (two-deep) component override', () => {\n        beforeEach(() => {\n            TestBed.configureTestingModule({\n                declarations: [ParentComponent, FakeChildWithGrandchildComponent, FakeGrandchildComponent]\n            });\n        });\n        it('should use Fake Grandchild component', () => {\n            const fixture = TestBed.createComponent(ParentComponent);\n            fixture.detectChanges();\n            expect(fixture).toHaveText('Parent(Fake Child(Fake Grandchild))');\n        });\n    });\n    describe('lifecycle hooks w/ MyIfParentComp', () => {\n        let fixture;\n        let parent;\n        let child;\n        beforeEach(() => {\n            TestBed.configureTestingModule({\n                imports: [FormsModule],\n                declarations: [MyIfChildComponent, MyIfParentComponent]\n            });\n            fixture = TestBed.createComponent(MyIfParentComponent);\n            parent = fixture.componentInstance;\n        });\n        it('should instantiate parent component', () => {\n            expect(parent).not.toBeNull('parent component should exist');\n        });\n        it('parent component OnInit should NOT be called before first detectChanges()', () => {\n            expect(parent.ngOnInitCalled).toBe(false);\n        });\n        it('parent component OnInit should be called after first detectChanges()', () => {\n            fixture.detectChanges();\n            expect(parent.ngOnInitCalled).toBe(true);\n        });\n        it('child component should exist after OnInit', () => {\n            fixture.detectChanges();\n            getChild();\n            expect(child instanceof MyIfChildComponent).toBe(true, 'should create child');\n        });\n        it('should have called child component\\'s OnInit ', () => {\n            fixture.detectChanges();\n            getChild();\n            expect(child.ngOnInitCalled).toBe(true);\n        });\n        it('child component called OnChanges once', () => {\n            fixture.detectChanges();\n            getChild();\n            expect(child.ngOnChangesCounter).toBe(1);\n        });\n        it('changed parent value flows to child', () => {\n            fixture.detectChanges();\n            getChild();\n            parent.parentValue = 'foo';\n            fixture.detectChanges();\n            expect(child.ngOnChangesCounter).toBe(2, 'expected 2 changes: initial value and changed value');\n            expect(child.childValue).toBe('foo', 'childValue should eq changed parent value');\n        });\n        // must be async test to see child flow to parent\n        it('changed child value flows to parent', waitForAsync(() => {\n            fixture.detectChanges();\n            getChild();\n            child.childValue = 'bar';\n            return new Promise(resolve => {\n                // Wait one JS engine turn!\n                setTimeout(() => resolve(), 0);\n            })\n                .then(() => {\n                fixture.detectChanges();\n                expect(child.ngOnChangesCounter).toBe(2, 'expected 2 changes: initial value and changed value');\n                expect(parent.parentValue).toBe('bar', 'parentValue should eq changed parent value');\n            });\n        }));\n        it('clicking \"Close Child\" triggers child OnDestroy', () => {\n            fixture.detectChanges();\n            getChild();\n            const btn = fixture.debugElement.query(By.css('button'));\n            click(btn);\n            fixture.detectChanges();\n            expect(child.ngOnDestroyCalled).toBe(true);\n        });\n        ////// helpers ///\n        /**\n         * Get the MyIfChildComp from parent; fail w/ good message if cannot.\n         */\n        function getChild() {\n            let childDe; // DebugElement that should hold the MyIfChildComp\n            // The Hard Way: requires detailed knowledge of the parent template\n            try {\n                childDe = fixture.debugElement.children[4].children[0];\n            }\n            catch (err) { /* we'll report the error */ }\n            // DebugElement.queryAll: if we wanted all of many instances:\n            childDe = fixture.debugElement\n                .queryAll(de => de.componentInstance instanceof MyIfChildComponent)[0];\n            // WE'LL USE THIS APPROACH !\n            // DebugElement.query: find first instance (if any)\n            childDe = fixture.debugElement\n                .query(de => de.componentInstance instanceof MyIfChildComponent);\n            if (childDe && childDe.componentInstance) {\n                child = childDe.componentInstance;\n            }\n            else {\n                fail('Unable to find MyIfChildComp within MyIfParentComp');\n            }\n            return child;\n        }\n    });\n});\n////////// Fakes ///////////\nlet FakeChildComponent = class FakeChildComponent {\n};\nFakeChildComponent = __decorate([\n    Component({\n        selector: 'child-1',\n        template: `Fake Child`\n    })\n], FakeChildComponent);\nlet FakeChildWithGrandchildComponent = class FakeChildWithGrandchildComponent {\n};\nFakeChildWithGrandchildComponent = __decorate([\n    Component({\n        selector: 'child-1',\n        template: `Fake Child(<grandchild-1></grandchild-1>)`\n    })\n], FakeChildWithGrandchildComponent);\nlet FakeGrandchildComponent = class FakeGrandchildComponent {\n};\nFakeGrandchildComponent = __decorate([\n    Component({\n        selector: 'grandchild-1',\n        template: `Fake Grandchild`\n    })\n], FakeGrandchildComponent);\nlet FakeValueService = class FakeValueService extends ValueService {\n    constructor() {\n        super(...arguments);\n        this.value = 'faked value';\n    }\n};\nFakeValueService = __decorate([\n    Injectable()\n], FakeValueService);\n"]},"metadata":{},"sourceType":"module"}