{"ast":null,"code":"import { fakeAsync, TestBed, tick, waitForAsync } from '@angular/core/testing';\nimport { asyncData, asyncError } from '../../testing';\nimport { of, throwError } from 'rxjs';\nimport { last } from 'rxjs/operators';\nimport { TwainComponent } from './twain.component';\nimport { TwainService } from './twain.service';\ndescribe('TwainComponent', () => {\n  let component;\n  let fixture;\n  let getQuoteSpy;\n  let quoteEl;\n  let testQuote; // Helper function to get the error message element value\n  // An *ngIf keeps it out of the DOM until there is an error\n\n  const errorMessage = () => {\n    const el = fixture.nativeElement.querySelector('.error');\n    return el ? el.textContent : null;\n  };\n\n  beforeEach(() => {\n    testQuote = 'Test Quote'; // Create a fake TwainService object with a `getQuote()` spy\n\n    const twainService = jasmine.createSpyObj('TwainService', ['getQuote']); // Make the spy return a synchronous Observable with the test data\n\n    getQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n    TestBed.configureTestingModule({\n      declarations: [TwainComponent],\n      providers: [{\n        provide: TwainService,\n        useValue: twainService\n      }]\n    });\n    fixture = TestBed.createComponent(TwainComponent);\n    component = fixture.componentInstance;\n    quoteEl = fixture.nativeElement.querySelector('.twain');\n  });\n  describe('when test with synchronous observable', () => {\n    it('should not show quote before OnInit', () => {\n      expect(quoteEl.textContent).toBe('', 'nothing displayed');\n      expect(errorMessage()).toBeNull('should not show error element');\n      expect(getQuoteSpy.calls.any()).toBe(false, 'getQuote not yet called');\n    }); // The quote would not be immediately available if the service were truly async.\n\n    it('should show quote after component initialized', () => {\n      fixture.detectChanges(); // onInit()\n      // sync spy result shows testQuote immediately after init\n\n      expect(quoteEl.textContent).toBe(testQuote);\n      expect(getQuoteSpy.calls.any()).toBe(true, 'getQuote called');\n    }); // The error would not be immediately available if the service were truly async.\n    // Use `fakeAsync` because the component error calls `setTimeout`\n\n    it('should display error when TwainService fails', fakeAsync(() => {\n      // tell spy to return an error observable\n      getQuoteSpy.and.returnValue(throwError('TwainService test failure'));\n      fixture.detectChanges(); // onInit()\n      // sync spy errors immediately after init\n\n      tick(); // flush the component's setTimeout()\n\n      fixture.detectChanges(); // update errorMessage within setTimeout()\n\n      expect(errorMessage()).toMatch(/test failure/, 'should display error');\n      expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n    }));\n  });\n  describe('when test with asynchronous observable', () => {\n    beforeEach(() => {\n      // Simulate delayed observable values with the `asyncData()` helper\n      getQuoteSpy.and.returnValue(asyncData(testQuote));\n    });\n    it('should not show quote before OnInit', () => {\n      expect(quoteEl.textContent).toBe('', 'nothing displayed');\n      expect(errorMessage()).toBeNull('should not show error element');\n      expect(getQuoteSpy.calls.any()).toBe(false, 'getQuote not yet called');\n    });\n    it('should still not show quote after component initialized', () => {\n      fixture.detectChanges(); // getQuote service is async => still has not returned with quote\n      // so should show the start value, '...'\n\n      expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n      expect(errorMessage()).toBeNull('should not show error');\n      expect(getQuoteSpy.calls.any()).toBe(true, 'getQuote called');\n    });\n    it('should show quote after getQuote (fakeAsync)', fakeAsync(() => {\n      fixture.detectChanges(); // ngOnInit()\n\n      expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n      tick(); // flush the observable to get the quote\n\n      fixture.detectChanges(); // update view\n\n      expect(quoteEl.textContent).toBe(testQuote, 'should show quote');\n      expect(errorMessage()).toBeNull('should not show error');\n    }));\n    it('should show quote after getQuote (waitForAsync)', waitForAsync(() => {\n      fixture.detectChanges(); // ngOnInit()\n\n      expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n      fixture.whenStable().then(() => {\n        fixture.detectChanges(); // update view with quote\n\n        expect(quoteEl.textContent).toBe(testQuote);\n        expect(errorMessage()).toBeNull('should not show error');\n      });\n    }));\n    it('should show last quote (quote done)', done => {\n      fixture.detectChanges();\n      component.quote.pipe(last()).subscribe(() => {\n        fixture.detectChanges(); // update view with quote\n\n        expect(quoteEl.textContent).toBe(testQuote);\n        expect(errorMessage()).toBeNull('should not show error');\n        done();\n      });\n    });\n    it('should show quote after getQuote (spy done)', done => {\n      fixture.detectChanges(); // the spy's most recent call returns the observable with the test quote\n\n      getQuoteSpy.calls.mostRecent().returnValue.subscribe(() => {\n        fixture.detectChanges(); // update view with quote\n\n        expect(quoteEl.textContent).toBe(testQuote);\n        expect(errorMessage()).toBeNull('should not show error');\n        done();\n      });\n    });\n    it('should display error when TwainService fails', fakeAsync(() => {\n      // tell spy to return an async error observable\n      getQuoteSpy.and.returnValue(asyncError('TwainService test failure'));\n      fixture.detectChanges();\n      tick(); // component shows error after a setTimeout()\n\n      fixture.detectChanges(); // update error message\n\n      expect(errorMessage()).toMatch(/test failure/, 'should display error');\n      expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n    }));\n  });\n});","map":{"version":3,"sources":["/home/yadadev/work/trainings/mean/angular/angular_testing/src/app/twain/twain.component.spec.ts"],"names":["fakeAsync","TestBed","tick","waitForAsync","asyncData","asyncError","of","throwError","last","TwainComponent","TwainService","describe","component","fixture","getQuoteSpy","quoteEl","testQuote","errorMessage","el","nativeElement","querySelector","textContent","beforeEach","twainService","jasmine","createSpyObj","getQuote","and","returnValue","configureTestingModule","declarations","providers","provide","useValue","createComponent","componentInstance","it","expect","toBe","toBeNull","calls","any","detectChanges","toMatch","whenStable","then","done","quote","pipe","subscribe","mostRecent"],"mappings":"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","sourcesContent":["import { fakeAsync, TestBed, tick, waitForAsync } from '@angular/core/testing';\nimport { asyncData, asyncError } from '../../testing';\nimport { of, throwError } from 'rxjs';\nimport { last } from 'rxjs/operators';\nimport { TwainComponent } from './twain.component';\nimport { TwainService } from './twain.service';\ndescribe('TwainComponent', () => {\n    let component;\n    let fixture;\n    let getQuoteSpy;\n    let quoteEl;\n    let testQuote;\n    // Helper function to get the error message element value\n    // An *ngIf keeps it out of the DOM until there is an error\n    const errorMessage = () => {\n        const el = fixture.nativeElement.querySelector('.error');\n        return el ? el.textContent : null;\n    };\n    beforeEach(() => {\n        testQuote = 'Test Quote';\n        // Create a fake TwainService object with a `getQuote()` spy\n        const twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n        // Make the spy return a synchronous Observable with the test data\n        getQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n        TestBed.configureTestingModule({\n            declarations: [TwainComponent],\n            providers: [{ provide: TwainService, useValue: twainService }]\n        });\n        fixture = TestBed.createComponent(TwainComponent);\n        component = fixture.componentInstance;\n        quoteEl = fixture.nativeElement.querySelector('.twain');\n    });\n    describe('when test with synchronous observable', () => {\n        it('should not show quote before OnInit', () => {\n            expect(quoteEl.textContent).toBe('', 'nothing displayed');\n            expect(errorMessage()).toBeNull('should not show error element');\n            expect(getQuoteSpy.calls.any()).toBe(false, 'getQuote not yet called');\n        });\n        // The quote would not be immediately available if the service were truly async.\n        it('should show quote after component initialized', () => {\n            fixture.detectChanges(); // onInit()\n            // sync spy result shows testQuote immediately after init\n            expect(quoteEl.textContent).toBe(testQuote);\n            expect(getQuoteSpy.calls.any()).toBe(true, 'getQuote called');\n        });\n        // The error would not be immediately available if the service were truly async.\n        // Use `fakeAsync` because the component error calls `setTimeout`\n        it('should display error when TwainService fails', fakeAsync(() => {\n            // tell spy to return an error observable\n            getQuoteSpy.and.returnValue(throwError('TwainService test failure'));\n            fixture.detectChanges(); // onInit()\n            // sync spy errors immediately after init\n            tick(); // flush the component's setTimeout()\n            fixture.detectChanges(); // update errorMessage within setTimeout()\n            expect(errorMessage()).toMatch(/test failure/, 'should display error');\n            expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n        }));\n    });\n    describe('when test with asynchronous observable', () => {\n        beforeEach(() => {\n            // Simulate delayed observable values with the `asyncData()` helper\n            getQuoteSpy.and.returnValue(asyncData(testQuote));\n        });\n        it('should not show quote before OnInit', () => {\n            expect(quoteEl.textContent).toBe('', 'nothing displayed');\n            expect(errorMessage()).toBeNull('should not show error element');\n            expect(getQuoteSpy.calls.any()).toBe(false, 'getQuote not yet called');\n        });\n        it('should still not show quote after component initialized', () => {\n            fixture.detectChanges();\n            // getQuote service is async => still has not returned with quote\n            // so should show the start value, '...'\n            expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n            expect(errorMessage()).toBeNull('should not show error');\n            expect(getQuoteSpy.calls.any()).toBe(true, 'getQuote called');\n        });\n        it('should show quote after getQuote (fakeAsync)', fakeAsync(() => {\n            fixture.detectChanges(); // ngOnInit()\n            expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n            tick(); // flush the observable to get the quote\n            fixture.detectChanges(); // update view\n            expect(quoteEl.textContent).toBe(testQuote, 'should show quote');\n            expect(errorMessage()).toBeNull('should not show error');\n        }));\n        it('should show quote after getQuote (waitForAsync)', waitForAsync(() => {\n            fixture.detectChanges(); // ngOnInit()\n            expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n            fixture.whenStable().then(() => {\n                fixture.detectChanges(); // update view with quote\n                expect(quoteEl.textContent).toBe(testQuote);\n                expect(errorMessage()).toBeNull('should not show error');\n            });\n        }));\n        it('should show last quote (quote done)', (done) => {\n            fixture.detectChanges();\n            component.quote.pipe(last()).subscribe(() => {\n                fixture.detectChanges(); // update view with quote\n                expect(quoteEl.textContent).toBe(testQuote);\n                expect(errorMessage()).toBeNull('should not show error');\n                done();\n            });\n        });\n        it('should show quote after getQuote (spy done)', (done) => {\n            fixture.detectChanges();\n            // the spy's most recent call returns the observable with the test quote\n            getQuoteSpy.calls.mostRecent().returnValue.subscribe(() => {\n                fixture.detectChanges(); // update view with quote\n                expect(quoteEl.textContent).toBe(testQuote);\n                expect(errorMessage()).toBeNull('should not show error');\n                done();\n            });\n        });\n        it('should display error when TwainService fails', fakeAsync(() => {\n            // tell spy to return an async error observable\n            getQuoteSpy.and.returnValue(asyncError('TwainService test failure'));\n            fixture.detectChanges();\n            tick(); // component shows error after a setTimeout()\n            fixture.detectChanges(); // update error message\n            expect(errorMessage()).toMatch(/test failure/, 'should display error');\n            expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n        }));\n    });\n});\n"]},"metadata":{},"sourceType":"module"}