{"ast":null,"code":"// tslint:disable-next-line:no-unused-variable\nimport { fakeAsync, tick, waitForAsync } from '@angular/core/testing';\nimport { interval, of } from 'rxjs';\nimport { delay, take } from 'rxjs/operators';\ndescribe('Angular async helper', () => {\n  describe('async', () => {\n    let actuallyDone = false;\n    beforeEach(() => {\n      actuallyDone = false;\n    });\n    afterEach(() => {\n      expect(actuallyDone).toBe(true, 'actuallyDone should be true');\n    });\n    it('should run normal test', () => {\n      actuallyDone = true;\n    });\n    it('should run normal async test', done => {\n      setTimeout(() => {\n        actuallyDone = true;\n        done();\n      }, 0);\n    });\n    it('should run async test with task', waitForAsync(() => {\n      setTimeout(() => {\n        actuallyDone = true;\n      }, 0);\n    }));\n    it('should run async test with task', waitForAsync(() => {\n      const id = setInterval(() => {\n        actuallyDone = true;\n        clearInterval(id);\n      }, 100);\n    }));\n    it('should run async test with successful promise', waitForAsync(() => {\n      const p = new Promise(resolve => {\n        setTimeout(resolve, 10);\n      });\n      p.then(() => {\n        actuallyDone = true;\n      });\n    }));\n    it('should run async test with failed promise', waitForAsync(() => {\n      const p = new Promise((resolve, reject) => {\n        setTimeout(reject, 10);\n      });\n      p.catch(() => {\n        actuallyDone = true;\n      });\n    })); // Use done. Can also use async or fakeAsync.\n\n    it('should run async test with successful delayed Observable', done => {\n      const source = of(true).pipe(delay(10));\n      source.subscribe(val => actuallyDone = true, err => fail(err), done);\n    });\n    it('should run async test with successful delayed Observable', waitForAsync(() => {\n      const source = of(true).pipe(delay(10));\n      source.subscribe(val => actuallyDone = true, err => fail(err));\n    }));\n    it('should run async test with successful delayed Observable', fakeAsync(() => {\n      const source = of(true).pipe(delay(10));\n      source.subscribe(val => actuallyDone = true, err => fail(err));\n      tick(10);\n    }));\n  });\n  describe('fakeAsync', () => {\n    it('should run timeout callback with delay after call tick with millis', fakeAsync(() => {\n      let called = false;\n      setTimeout(() => {\n        called = true;\n      }, 100);\n      tick(100);\n      expect(called).toBe(true);\n    }));\n    it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => {\n      function nestedTimer(cb) {\n        setTimeout(() => setTimeout(() => cb()));\n      }\n\n      const callback = jasmine.createSpy('callback');\n      nestedTimer(callback);\n      expect(callback).not.toHaveBeenCalled();\n      tick(0); // the nested timeout will also be triggered\n\n      expect(callback).toHaveBeenCalled();\n    }));\n    it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => {\n      function nestedTimer(cb) {\n        setTimeout(() => setTimeout(() => cb()));\n      }\n\n      const callback = jasmine.createSpy('callback');\n      nestedTimer(callback);\n      expect(callback).not.toHaveBeenCalled();\n      tick(0, {\n        processNewMacroTasksSynchronously: false\n      }); // the nested timeout will not be triggered\n\n      expect(callback).not.toHaveBeenCalled();\n      tick(0);\n      expect(callback).toHaveBeenCalled();\n    }));\n    it('should get Date diff correctly in fakeAsync', fakeAsync(() => {\n      const start = Date.now();\n      tick(100);\n      const end = Date.now();\n      expect(end - start).toBe(100);\n    }));\n    it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => {\n      // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'\n      // to patch rxjs scheduler\n      let result = '';\n      of('hello').pipe(delay(1000)).subscribe(v => {\n        result = v;\n      });\n      expect(result).toBe('');\n      tick(1000);\n      expect(result).toBe('hello');\n      const start = new Date().getTime();\n      let dateDiff = 0;\n      interval(1000).pipe(take(2)).subscribe(() => dateDiff = new Date().getTime() - start);\n      tick(1000);\n      expect(dateDiff).toBe(1000);\n      tick(1000);\n      expect(dateDiff).toBe(2000);\n    }));\n  });\n  describe('use jasmine.clock()', () => {\n    // need to config __zone_symbol__fakeAsyncPatchLock flag\n    // before loading zone.js/testing\n    beforeEach(() => {\n      jasmine.clock().install();\n    });\n    afterEach(() => {\n      jasmine.clock().uninstall();\n    });\n    it('should auto enter fakeAsync', () => {\n      // is in fakeAsync now, don't need to call fakeAsync(testFn)\n      let called = false;\n      setTimeout(() => {\n        called = true;\n      }, 100);\n      jasmine.clock().tick(100);\n      expect(called).toBe(true);\n    });\n  });\n  describe('test jsonp', () => {\n    function jsonp(url, callback) {// do a jsonp call which is not zone aware\n    } // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag\n    // before loading zone.js/testing\n\n\n    it('should wait until promise.then is called', waitForAsync(() => {\n      let finished = false;\n      new Promise(res => {\n        jsonp('localhost:8080/jsonp', () => {\n          // success callback and resolve the promise\n          finished = true;\n          res();\n        });\n      }).then(() => {\n        // async will wait until promise.then is called\n        // if __zone_symbol__supportWaitUnResolvedChainedPromise is set\n        expect(finished).toBe(true);\n      });\n    }));\n  });\n});","map":{"version":3,"sources":["/home/yadadev/work/trainings/mean/angular/angular_testing/src/app/demo/async-helper.spec.ts"],"names":["fakeAsync","tick","waitForAsync","interval","of","delay","take","describe","actuallyDone","beforeEach","afterEach","expect","toBe","it","done","setTimeout","id","setInterval","clearInterval","p","Promise","resolve","then","reject","catch","source","pipe","subscribe","val","err","fail","called","nestedTimer","cb","callback","jasmine","createSpy","not","toHaveBeenCalled","processNewMacroTasksSynchronously","start","Date","now","end","result","v","getTime","dateDiff","clock","install","uninstall","jsonp","url","finished","res"],"mappings":"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","sourcesContent":["// tslint:disable-next-line:no-unused-variable\nimport { fakeAsync, tick, waitForAsync } from '@angular/core/testing';\nimport { interval, of } from 'rxjs';\nimport { delay, take } from 'rxjs/operators';\ndescribe('Angular async helper', () => {\n    describe('async', () => {\n        let actuallyDone = false;\n        beforeEach(() => {\n            actuallyDone = false;\n        });\n        afterEach(() => {\n            expect(actuallyDone).toBe(true, 'actuallyDone should be true');\n        });\n        it('should run normal test', () => {\n            actuallyDone = true;\n        });\n        it('should run normal async test', (done) => {\n            setTimeout(() => {\n                actuallyDone = true;\n                done();\n            }, 0);\n        });\n        it('should run async test with task', waitForAsync(() => {\n            setTimeout(() => {\n                actuallyDone = true;\n            }, 0);\n        }));\n        it('should run async test with task', waitForAsync(() => {\n            const id = setInterval(() => {\n                actuallyDone = true;\n                clearInterval(id);\n            }, 100);\n        }));\n        it('should run async test with successful promise', waitForAsync(() => {\n            const p = new Promise(resolve => {\n                setTimeout(resolve, 10);\n            });\n            p.then(() => {\n                actuallyDone = true;\n            });\n        }));\n        it('should run async test with failed promise', waitForAsync(() => {\n            const p = new Promise((resolve, reject) => {\n                setTimeout(reject, 10);\n            });\n            p.catch(() => {\n                actuallyDone = true;\n            });\n        }));\n        // Use done. Can also use async or fakeAsync.\n        it('should run async test with successful delayed Observable', (done) => {\n            const source = of(true).pipe(delay(10));\n            source.subscribe(val => actuallyDone = true, err => fail(err), done);\n        });\n        it('should run async test with successful delayed Observable', waitForAsync(() => {\n            const source = of(true).pipe(delay(10));\n            source.subscribe(val => actuallyDone = true, err => fail(err));\n        }));\n        it('should run async test with successful delayed Observable', fakeAsync(() => {\n            const source = of(true).pipe(delay(10));\n            source.subscribe(val => actuallyDone = true, err => fail(err));\n            tick(10);\n        }));\n    });\n    describe('fakeAsync', () => {\n        it('should run timeout callback with delay after call tick with millis', fakeAsync(() => {\n            let called = false;\n            setTimeout(() => {\n                called = true;\n            }, 100);\n            tick(100);\n            expect(called).toBe(true);\n        }));\n        it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => {\n            function nestedTimer(cb) {\n                setTimeout(() => setTimeout(() => cb()));\n            }\n            const callback = jasmine.createSpy('callback');\n            nestedTimer(callback);\n            expect(callback).not.toHaveBeenCalled();\n            tick(0);\n            // the nested timeout will also be triggered\n            expect(callback).toHaveBeenCalled();\n        }));\n        it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => {\n            function nestedTimer(cb) {\n                setTimeout(() => setTimeout(() => cb()));\n            }\n            const callback = jasmine.createSpy('callback');\n            nestedTimer(callback);\n            expect(callback).not.toHaveBeenCalled();\n            tick(0, { processNewMacroTasksSynchronously: false });\n            // the nested timeout will not be triggered\n            expect(callback).not.toHaveBeenCalled();\n            tick(0);\n            expect(callback).toHaveBeenCalled();\n        }));\n        it('should get Date diff correctly in fakeAsync', fakeAsync(() => {\n            const start = Date.now();\n            tick(100);\n            const end = Date.now();\n            expect(end - start).toBe(100);\n        }));\n        it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => {\n            // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'\n            // to patch rxjs scheduler\n            let result = '';\n            of('hello').pipe(delay(1000)).subscribe(v => {\n                result = v;\n            });\n            expect(result).toBe('');\n            tick(1000);\n            expect(result).toBe('hello');\n            const start = new Date().getTime();\n            let dateDiff = 0;\n            interval(1000).pipe(take(2)).subscribe(() => dateDiff = (new Date().getTime() - start));\n            tick(1000);\n            expect(dateDiff).toBe(1000);\n            tick(1000);\n            expect(dateDiff).toBe(2000);\n        }));\n    });\n    describe('use jasmine.clock()', () => {\n        // need to config __zone_symbol__fakeAsyncPatchLock flag\n        // before loading zone.js/testing\n        beforeEach(() => {\n            jasmine.clock().install();\n        });\n        afterEach(() => {\n            jasmine.clock().uninstall();\n        });\n        it('should auto enter fakeAsync', () => {\n            // is in fakeAsync now, don't need to call fakeAsync(testFn)\n            let called = false;\n            setTimeout(() => {\n                called = true;\n            }, 100);\n            jasmine.clock().tick(100);\n            expect(called).toBe(true);\n        });\n    });\n    describe('test jsonp', () => {\n        function jsonp(url, callback) {\n            // do a jsonp call which is not zone aware\n        }\n        // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag\n        // before loading zone.js/testing\n        it('should wait until promise.then is called', waitForAsync(() => {\n            let finished = false;\n            new Promise(res => {\n                jsonp('localhost:8080/jsonp', () => {\n                    // success callback and resolve the promise\n                    finished = true;\n                    res();\n                });\n            }).then(() => {\n                // async will wait until promise.then is called\n                // if __zone_symbol__supportWaitUnResolvedChainedPromise is set\n                expect(finished).toBe(true);\n            });\n        }));\n    });\n});\n"]},"metadata":{},"sourceType":"module"}